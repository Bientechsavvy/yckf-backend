// ============================================
// YCKF BACKEND SERVER - PRODUCTION READY
// File: server.js
// ============================================

const express = require('express');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const { v4: uuidv4 } = require('uuid');
const rateLimit = require('express-rate-limit');
const cors = require('cors');
require('dotenv').config();

const app = express();

// ============================================
// MIDDLEWARE
// ============================================
app.use(express.json());
app.use(cors());

// ============================================
// CONFIGURATION
// ============================================
const JWT_SECRET = process.env.JWT_SECRET || 'your-super-secret-jwt-key-change-in-production';
const PORT = process.env.PORT || 3000;
const NODE_ENV = process.env.NODE_ENV || 'development';

// ============================================
// IN-MEMORY DATABASES (Replace with real DB in production)
// ============================================
const users = [
  {
    id: 'user-1',
    email: 'admin@yckf.org',
    name: 'YCKF Admin',
    passwordHash: bcrypt.hashSync('SecureAdmin@2024', 10),
    role: 'admin',
    createdAt: new Date().toISOString(),
  },
  {
    id: 'user-2',
    email: 'user@yckf.org',
    name: 'Test User',
    passwordHash: bcrypt.hashSync('TestUser@2024', 10),
    role: 'user',
    createdAt: new Date().toISOString(),
  }
];

const subscriptions = [];
const coupons = [];
const couponRedemptions = [];
const demoSessions = [];
const auditLogs = [];

// Demo token (rotate this regularly in production)
let currentDemoToken = bcrypt.hashSync('DEMO-YCKF-2024', 10);

// ============================================
// RATE LIMITING
// ============================================
const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 5, // 5 attempts
  message: { error: 'Too many login attempts, please try again later' }
});

const couponLimiter = rateLimit({
  windowMs: 60 * 1000, // 1 minute
  max: 10, // 10 attempts
  message: { error: 'Too many coupon attempts, please slow down' }
});

// ============================================
// MIDDLEWARE - JWT VERIFICATION
// ============================================
function authenticateToken(req, res, next) {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];

  if (!token) {
    return res.status(401).json({ error: 'Access token required' });
  }

  jwt.verify(token, JWT_SECRET, (err, user) => {
    if (err) {
      return res.status(403).json({ error: 'Invalid or expired token' });
    }
    req.user = user;
    next();
  });
}

// ============================================
// MIDDLEWARE - ADMIN ONLY
// ============================================
function requireAdmin(req, res, next) {
  if (req.user.role !== 'admin') {
    logAudit('UNAUTHORIZED_ADMIN_ACCESS_ATTEMPT', req.user.id, null, { 
      endpoint: req.path 
    });
    return res.status(403).json({ error: 'Admin access required' });
  }
  next();
}

// ============================================
// AUDIT LOGGING
// ============================================
function logAudit(action, performedBy, targetUser, details) {
  auditLogs.push({
    timestamp: new Date().toISOString(),
    action,
    performedBy,
    targetUser,
    details
  });
  console.log(`[AUDIT] ${action} by ${performedBy}`, details);
}

// ============================================
// HEALTH CHECK
// ============================================
app.get('/', (req, res) => {
  res.json({
    status: 'ok',
    message: 'YCKF Backend API',
    version: '1.0.0',
    environment: NODE_ENV
  });
});

app.get('/health', (req, res) => {
  res.json({
    status: 'healthy',
    timestamp: new Date().toISOString(),
    uptime: process.uptime()
  });
});

// ============================================
// 1. AUTHENTICATION ENDPOINTS
// ============================================

// Register new user
app.post('/auth/register', async (req, res) => {
  try {
    const { email, password, name } = req.body;

    if (!email || !password) {
      return res.status(400).json({ error: 'Email and password required' });
    }

    // Validate email format
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(email)) {
      return res.status(400).json({ error: 'Invalid email format' });
    }

    // Check if user exists
    const existingUser = users.find(u => u.email.toLowerCase() === email.toLowerCase());
    if (existingUser) {
      return res.status(400).json({ error: 'User already exists' });
    }

    // Create user
    const passwordHash = await bcrypt.hash(password, 10);
    const newUser = {
      id: uuidv4(),
      email: email.toLowerCase(),
      name: name || email.split('@')[0],
      passwordHash,
      role: 'user',
      createdAt: new Date().toISOString(),
    };

    users.push(newUser);

    logAudit('USER_REGISTERED', newUser.id, newUser.id, { email: newUser.email });

    // Generate token
    const token = jwt.sign(
      { id: newUser.id, email: newUser.email, role: newUser.role },
      JWT_SECRET,
      { expiresIn: '7d' }
    );

    res.json({
      success: true,
      token,
      user: {
        id: newUser.id,
        email: newUser.email,
        name: newUser.name,
        role: newUser.role
      }
    });
  } catch (error) {
    console.error('Registration error:', error);
    res.status(500).json({ error: 'Registration failed' });
  }
});

// Login
app.post('/auth/login', authLimiter, async (req, res) => {
  try {
    const { email, password } = req.body;

    if (!email || !password) {
      return res.status(400).json({ error: 'Email and password required' });
    }

    // Find user
    const user = users.find(u => u.email.toLowerCase() === email.toLowerCase());
    if (!user) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }

    // Verify password
    const validPassword = await bcrypt.compare(password, user.passwordHash);
    if (!validPassword) {
      logAudit('FAILED_LOGIN_ATTEMPT', email, user.id, { email });
      return res.status(401).json({ error: 'Invalid credentials' });
    }

    logAudit('USER_LOGIN', user.id, user.id, { email });

    // Generate token
    const token = jwt.sign(
      { id: user.id, email: user.email, role: user.role },
      JWT_SECRET,
      { expiresIn: '7d' }
    );

    res.json({
      success: true,
      token,
      user: {
        id: user.id,
        email: user.email,
        name: user.name,
        role: user.role
      }
    });
  } catch (error) {
    console.error('Login error:', error);
    res.status(500).json({ error: 'Login failed' });
  }
});

// Logout
app.post('/auth/logout', authenticateToken, (req, res) => {
  logAudit('USER_LOGOUT', req.user.id, req.user.id, {});
  res.json({ success: true, message: 'Logged out successfully' });
});

// Get current user
app.get('/auth/me', authenticateToken, (req, res) => {
  const user = users.find(u => u.id === req.user.id);
  if (!user) {
    return res.status(404).json({ error: 'User not found' });
  }

  res.json({
    id: user.id,
    email: user.email,
    name: user.name,
    role: user.role
  });
});

// ============================================
// 2. PREMIUM ENTITLEMENT ENDPOINT
// ============================================
app.get('/entitlements', authenticateToken, (req, res) => {
  const userId = req.user.id;
  const user = users.find(u => u.id === userId);

  if (!user) {
    return res.status(404).json({ error: 'User not found' });
  }

  // Check 1: Admin Role
  if (user.role === 'admin') {
    return res.json({
      premium: true,
      reason: 'admin',
      adminRole: true,
      subscriptionActive: false,
      couponSessionActive: false,
      demoSessionActive: false
    });
  }

  // Check 2: Active Subscription
  const subscription = subscriptions.find(
    s => s.userId === userId && s.isActive && new Date(s.expiresAt) > new Date()
  );
  if (subscription) {
    return res.json({
      premium: true,
      reason: 'subscription',
      adminRole: false,
      subscriptionActive: true,
      couponSessionActive: false,
      demoSessionActive: false,
      expiresAt: subscription.expiresAt
    });
  }

  // Check 3: Active Coupon Redemption
  const activeCoupon = couponRedemptions.find(
    r => r.userId === userId && r.isActive && new Date(r.expiresAt) > new Date()
  );
  if (activeCoupon) {
    const timeRemaining = Math.floor((new Date(activeCoupon.expiresAt) - new Date()) / 60000);
    return res.json({
      premium: true,
      reason: 'coupon',
      adminRole: false,
      subscriptionActive: false,
      couponSessionActive: true,
      demoSessionActive: false,
      expiresAt: activeCoupon.expiresAt,
      timeRemaining
    });
  }

  // Check 4: Active Demo Session
  const demoSession = demoSessions.find(
    s => s.userId === userId && s.isActive && new Date(s.expiresAt) > new Date()
  );
  if (demoSession) {
    const timeRemaining = Math.floor((new Date(demoSession.expiresAt) - new Date()) / 60000);
    return res.json({
      premium: true,
      reason: 'demo',
      adminRole: false,
      subscriptionActive: false,
      couponSessionActive: false,
      demoSessionActive: true,
      expiresAt: demoSession.expiresAt,
      timeRemaining
    });
  }

  // No premium access
  res.json({
    premium: false,
    reason: 'none',
    adminRole: false,
    subscriptionActive: false,
    couponSessionActive: false,
    demoSessionActive: false
  });
});

// ============================================
// 3. SUBSCRIPTION ENDPOINTS
// ============================================

// Activate subscription after payment
app.post('/subscriptions/activate', authenticateToken, (req, res) => {
  try {
    const { paymentReference, paymentMethod } = req.body;
    const userId = req.user.id;

    const activatedAt = new Date().toISOString();
    const expiresAt = new Date(Date.now() + 365 * 24 * 60 * 60 * 1000).toISOString();

    const subscription = {
      id: uuidv4(),
      userId,
      isActive: true,
      activatedAt,
      expiresAt,
      paymentReference,
      paymentMethod
    };

    subscriptions.push(subscription);

    logAudit('SUBSCRIPTION_ACTIVATED', userId, userId, { 
      paymentReference, 
      paymentMethod 
    });

    res.json({
      success: true,
      subscription: {
        activatedAt,
        expiresAt
      }
    });
  } catch (error) {
    console.error('Subscription activation error:', error);
    res.status(500).json({ error: 'Failed to activate subscription' });
  }
});

// ============================================
// 4. COUPON ENDPOINTS
// ============================================

// Validate coupon
app.post('/coupons/validate', authenticateToken, couponLimiter, (req, res) => {
  try {
    const { couponCode } = req.body;

    if (!couponCode) {
      return res.status(400).json({ valid: false, message: 'Coupon code required' });
    }

    const coupon = coupons.find(c => c.code.toUpperCase() === couponCode.toUpperCase());

    if (!coupon) {
      return res.json({ valid: false, message: 'Invalid coupon code' });
    }

    if (!coupon.isActive) {
      return res.json({ valid: false, message: 'This coupon has been deactivated' });
    }

    if (coupon.expiresAt && new Date(coupon.expiresAt) < new Date()) {
      return res.json({ valid: false, message: 'This coupon has expired' });
    }

    if (coupon.maxRedemptions && coupon.currentRedemptions >= coupon.maxRedemptions) {
      return res.json({ valid: false, message: 'This coupon has reached its maximum usage limit' });
    }

    res.json({
      valid: true,
      message: 'Coupon is valid',
      description: coupon.description,
      maxRedemptions: coupon.maxRedemptions,
      currentRedemptions: coupon.currentRedemptions
    });
  } catch (error) {
    console.error('Coupon validation error:', error);
    res.status(500).json({ valid: false, message: 'Validation failed' });
  }
});

// Redeem coupon
app.post('/coupons/redeem', authenticateToken, couponLimiter, (req, res) => {
  try {
    const { couponCode, durationHours } = req.body;
    const userId = req.user.id;

    if (!couponCode || !durationHours) {
      return res.status(400).json({ error: 'Coupon code and duration required' });
    }

    if (![12, 24].includes(durationHours)) {
      return res.status(400).json({ error: 'Duration must be 12 or 24 hours' });
    }

    const coupon = coupons.find(c => c.code.toUpperCase() === couponCode.toUpperCase());

    if (!coupon || !coupon.isActive) {
      return res.status(400).json({ error: 'Invalid or inactive coupon' });
    }

    if (coupon.maxRedemptions && coupon.currentRedemptions >= coupon.maxRedemptions) {
      return res.status(400).json({ error: 'Coupon usage limit reached' });
    }

    // Check if user already has active redemption
    const existingRedemption = couponRedemptions.find(
      r => r.userId === userId && r.isActive && new Date(r.expiresAt) > new Date()
    );

    if (existingRedemption) {
      return res.status(400).json({ 
        error: 'You already have an active coupon session',
        expiresAt: existingRedemption.expiresAt
      });
    }

    const redeemedAt = new Date().toISOString();
    const expiresAt = new Date(Date.now() + durationHours * 60 * 60 * 1000).toISOString();

    const redemption = {
      id: uuidv4(),
      couponCode: coupon.code,
      userId,
      redeemedAt,
      expiresAt,
      isActive: true,
      accessDuration: durationHours
    };

    couponRedemptions.push(redemption);
    coupon.currentRedemptions++;

    logAudit('COUPON_REDEEMED', userId, userId, { 
      couponCode: coupon.code, 
      durationHours 
    });

    res.json({
      success: true,
      redemption: {
        redeemedAt,
        expiresAt,
        accessDuration: durationHours
      }
    });
  } catch (error) {
    console.error('Coupon redemption error:', error);
    res.status(500).json({ error: 'Failed to redeem coupon' });
  }
});

// ============================================
// 5. DEMO ACCESS ENDPOINTS
// ============================================

// Activate demo session
app.post('/admin/demo/activate', authenticateToken, couponLimiter, async (req, res) => {
  try {
    const { demoToken, deviceId } = req.body;
    const userId = req.user.id;

    if (!demoToken) {
      return res.status(400).json({ error: 'Demo token required' });
    }

    const validToken = await bcrypt.compare(demoToken, currentDemoToken);
    
    if (!validToken) {
      logAudit('FAILED_DEMO_TOKEN_ATTEMPT', userId, userId, { deviceId });
      return res.status(401).json({ error: 'Invalid demo token' });
    }

    const existingSession = demoSessions.find(
      s => s.userId === userId && s.isActive && new Date(s.expiresAt) > new Date()
    );

    if (existingSession) {
      const timeRemaining = Math.floor((new Date(existingSession.expiresAt) - new Date()) / 60000);
      return res.json({
        success: true,
        premium: true,
        reason: 'demo',
        demoSessionActive: true,
        expiresAt: existingSession.expiresAt,
        timeRemaining,
        message: 'Demo session already active'
      });
    }

    const expiresAt = new Date(Date.now() + 60 * 60 * 1000).toISOString();
    
    const demoSession = {
      id: uuidv4(),
      userId,
      token: demoToken,
      expiresAt,
      isActive: true,
      deviceId
    };

    demoSessions.push(demoSession);

    logAudit('DEMO_SESSION_ACTIVATED', userId, userId, { deviceId });

    res.json({
      success: true,
      premium: true,
      reason: 'demo',
      demoSessionActive: true,
      expiresAt,
      timeRemaining: 60
    });
  } catch (error) {
    console.error('Demo activation error:', error);
    res.status(500).json({ error: 'Failed to activate demo session' });
  }
});

// ============================================
// 6. ADMIN ENDPOINTS
// ============================================

// Create coupon (Admin only)
app.post('/admin/coupons/create', authenticateToken, requireAdmin, (req, res) => {
  try {
    const { code, description, expiresAt, maxRedemptions } = req.body;

    if (!code) {
      return res.status(400).json({ error: 'Coupon code required' });
    }

    const existingCoupon = coupons.find(c => c.code.toUpperCase() === code.toUpperCase());
    if (existingCoupon) {
      return res.status(400).json({ error: 'Coupon code already exists' });
    }

    const coupon = {
      id: uuidv4(),
      code: code.toUpperCase(),
      isActive: true,
      createdAt: new Date().toISOString(),
      createdBy: req.user.email,
      expiresAt: expiresAt || null,
      maxRedemptions: maxRedemptions || null,
      currentRedemptions: 0,
      description: description || null
    };

    coupons.push(coupon);

    logAudit('COUPON_CREATED', req.user.id, null, { code: coupon.code });

    res.json({
      success: true,
      coupon
    });
  } catch (error) {
    console.error('Coupon creation error:', error);
    res.status(500).json({ error: 'Failed to create coupon' });
  }
});

// Get all coupons (Admin only)
app.get('/admin/coupons', authenticateToken, requireAdmin, (req, res) => {
  res.json({ coupons });
});

// Deactivate coupon (Admin only)
app.post('/admin/coupons/deactivate', authenticateToken, requireAdmin, (req, res) => {
  try {
    const { code } = req.body;

    const coupon = coupons.find(c => c.code.toUpperCase() === code.toUpperCase());
    if (!coupon) {
      return res.status(404).json({ error: 'Coupon not found' });
    }

    coupon.isActive = false;

    logAudit('COUPON_DEACTIVATED', req.user.id, null, { code });

    res.json({ success: true, message: 'Coupon deactivated' });
  } catch (error) {
    console.error('Coupon deactivation error:', error);
    res.status(500).json({ error: 'Failed to deactivate coupon' });
  }
});

// Reactivate coupon (Admin only)
app.post('/admin/coupons/reactivate', authenticateToken, requireAdmin, (req, res) => {
  try {
    const { code } = req.body;

    const coupon = coupons.find(c => c.code.toUpperCase() === code.toUpperCase());
    if (!coupon) {
      return res.status(404).json({ error: 'Coupon not found' });
    }

    coupon.isActive = true;

    logAudit('COUPON_REACTIVATED', req.user.id, null, { code });

    res.json({ success: true, message: 'Coupon reactivated' });
  } catch (error) {
    console.error('Coupon reactivation error:', error);
    res.status(500).json({ error: 'Failed to reactivate coupon' });
  }
});

// Get all redemptions (Admin only)
app.get('/admin/redemptions', authenticateToken, requireAdmin, (req, res) => {
  res.json({ redemptions: couponRedemptions });
});

// Get audit logs (Admin only)
app.get('/admin/audit-logs', authenticateToken, requireAdmin, (req, res) => {
  const limit = parseInt(req.query.limit) || 100;
  const logs = auditLogs.slice(-limit).reverse();
  res.json({ logs });
});

// Rotate demo token (Admin only)
app.post('/admin/demo/rotate-token', authenticateToken, requireAdmin, async (req, res) => {
  try {
    const { newToken } = req.body;

    if (!newToken) {
      return res.status(400).json({ error: 'New token required' });
    }

    currentDemoToken = await bcrypt.hash(newToken, 10);
    demoSessions.forEach(s => { s.isActive = false; });

    logAudit('DEMO_TOKEN_ROTATED', req.user.id, null, {});

    res.json({ 
      success: true, 
      message: 'Demo token rotated and all sessions revoked' 
    });
  } catch (error) {
    console.error('Token rotation error:', error);
    res.status(500).json({ error: 'Failed to rotate token' });
  }
});

// ============================================
// CLEANUP EXPIRED SESSIONS
// ============================================
setInterval(() => {
  const now = new Date();
  
  couponRedemptions.forEach(r => {
    if (r.isActive && new Date(r.expiresAt) < now) {
      r.isActive = false;
      console.log(`[CLEANUP] Deactivated expired coupon: ${r.id}`);
    }
  });

  demoSessions.forEach(s => {
    if (s.isActive && new Date(s.expiresAt) < now) {
      s.isActive = false;
      console.log(`[CLEANUP] Deactivated expired demo: ${s.id}`);
    }
  });

  subscriptions.forEach(s => {
    if (s.isActive && new Date(s.expiresAt) < now) {
      s.isActive = false;
      console.log(`[CLEANUP] Deactivated expired subscription: ${s.id}`);
    }
  });
}, 60000);

// ============================================
// ERROR HANDLING
// ============================================
app.use((err, req, res, next) => {
  console.error('Server error:', err);
  res.status(500).json({ error: 'Internal server error' });
});

// ============================================
// START SERVER
// ============================================
app.listen(PORT, () => {
  console.log(`\nğŸš€ YCKF Backend Server running on port ${PORT}`);
  console.log(`ğŸ“ Environment: ${NODE_ENV}`);
  console.log(`\nğŸ“ Default Users:`);
  console.log(`   Admin: admin@yckf.org / SecureAdmin@2024`);
  console.log(`   User:  user@yckf.org / TestUser@2024`);
  console.log(`\nğŸ” Demo Token: DEMO-YCKF-2024`);
  console.log(`\nâš ï¸  Production checklist:`);
  console.log(`   âœ“ Change JWT_SECRET`);
  console.log(`   âœ“ Use real database`);
  console.log(`   âœ“ Enable HTTPS`);
  console.log(`   âœ“ Set up monitoring\n`);
});
module.exports = app;